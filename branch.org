* Intro

This branch now lays the ground work for supporting Option 3 as
described in the RFC.

https://github.com/phillord/horned-owl/blob/rfc/swrl_rules_redesign.md

I have now created a new enum called Component instead of Axiom. Both
OntologyID and DocIRI are now Components. This greatly simplifies the
creation of iterators and so forth and new forms of indexed
ontology. Indeed, doc IRIs (if I created them routinely!) are now
passed around these transformations where they were not previously.

The disadvantage is it makes some manipulations harder, particularly
those that only care about Axioms. Removing the non-axiom components
is not too hard (a single filter). I should be able to improve this
when and if I get the a interface for ontology working which was
blocked on GATSs, but now seems possible.

https://github.com/phillord/horned-owl/tree/feature/collection-ontology-interface

Additionally, it makes the rules on exhaustive matching against
Component less useful.


* Support SWRL rules [4/11]

This branch is design to support SWRL rules, using Solution 3 from the
RFC branch.

 - [X] Rename Axiom to Component
 - [X] Rename AnnotatedAxiom to AnnotatedComponent
 - [X] Move OntologyID to be AnnotatedComponent
 - [ ] What about doc_iri
 - [X] Add is_axiom, is_id methods, macro'd out
 - [ ] How do we add "axiom_iter" convience methods? Give that
       Ontology has no interface per se.
 - [ ] Check all iterator examples to make sure they are using the
       right thing and should not use something else instead
 - [ ] Update `axiom` local variable names
 - [ ] Add SwrlRule (or SwrlComponent or equivalent)
 - [ ] Implement SwrlRule model
 - [ ] Update parsers



* Rename Axiom to Component [1/2]

 - [X] Change enum Axiom, struct AnnotatedAxiom
 - [ ] check instances of `axiom` as variable


* doc_iri

As far as I can see, I don't use the doc_iri support anywhere, and
certainly don't pass it between iterators. So, if we move them to
Component this will actually work


* Do we still need Axiom emun

In creating, Component it means I no longer have a representation of
Axiom. That means I am starting to write code like this:

        Ok(match self {
            // We render imports and ontology annotations earlier
            Component::OntologyID(_) => panic!("OntologyID found where only axioms were expected"),
            Component::DocIRI(_) => panic!("DocIRI found where only axioms were expected"),
            Component::Import(_ax) => vec![].into(),
            Component::OntologyAnnotation(_ax) => vec![].into(),
            Component::DeclareClass(ax) => ax.render(f, ng)?.into(),
            Component::DeclareObjectProperty(ax) => ax.render(f, ng)?.into(),

 which is a big ugly. But also, once I add SWRL rules will make the
 exhaustive matching capabilities of Rust a bit pointless

One solution would be to add back an Axiom enum which just takes the
Axiom components. Then I would have a SWRLEnum as well with into
convertors. Then I would add some convertor for filtermap

pub fn as_axiom(c: Component) -> Some(&
